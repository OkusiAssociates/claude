#!/bin/bash
# Remove enterprise rule duplicates from user ~/.claude/rules/ directories
#
# Usage: sudo ./claude.clean-user-rules [OPTIONS] [USER...]
#
set -euo pipefail
shopt -s inherit_errexit extglob nullglob shift_verbose

### VERSION
declare -r VERSION=1.0.0
###
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -- "$0")
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*}
declare -r SCRIPT_NAME=${SCRIPT_PATH##*/}

# Configuration
declare -r CLAUDE_GROUP=${CLAUDE_GROUP:-claude-users}
declare -r ENTERPRISE_RULES=/etc/claude-code/.claude/rules

# State
declare -i DRY_RUN=0
declare -i BACKUP=0
declare -i VERBOSE=0
declare -a EXCLUDE_USERS=()
declare -a TARGET_USERS=()

# Colors
if [[ -t 1 && -t 2 ]]; then
  declare -r RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[1;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
else
  declare -r RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi

info()   { >&2 echo -e "$SCRIPT_NAME: ${CYAN}◉${NC} $*"; }
status() { echo -e "$SCRIPT_NAME: ${GREEN}✓${NC} $*"; }
warn()   { >&2 echo -e "$SCRIPT_NAME: ${YELLOW}▲${NC} $*"; }
error()  { >&2 echo -e "$SCRIPT_NAME: ${RED}✗${NC} $*"; }
die()    { (($# < 2)) || error "${@:2}"; exit "${1:-0}"; }

show_help() {
  cat <<HELP
$SCRIPT_NAME $VERSION - Remove enterprise rule duplicates from user directories

USAGE
    sudo $SCRIPT_NAME [OPTIONS] [USER...]

OPTIONS
    -h, --help              Show this help message
    -V, --version           Show version
    -n, --dry-run           Preview changes without executing
    -b, --backup            Move files to ~/.claude/rules.bak/ instead of deleting
    -v, --verbose           Show each file processed
    -x, --exclude USER      Exclude user from cleanup (can be repeated)

DESCRIPTION
    Removes files from user ~/.claude/rules/ directories that duplicate
    files in ${ENTERPRISE_RULES@Q}.

    Claude Code loads user rules with higher priority than enterprise rules.
    If a user has copies of enterprise files, their stale copies will mask
    enterprise updates. This script removes those duplicates.

    By default, processes all users in the ${CLAUDE_GROUP@Q} group.
    Specify usernames as arguments to limit to specific users.

EXAMPLES
    # Preview what would be removed (all users)
    sudo $SCRIPT_NAME --dry-run

    # Clean all users, backing up removed files
    sudo $SCRIPT_NAME --backup

    # Clean specific user with verbose output
    sudo $SCRIPT_NAME -v sysadmin

    # Clean all users except netadmin
    sudo $SCRIPT_NAME --exclude netadmin

HELP
}

# Get list of users in claude-users group
get_group_members() {
  getent group "$CLAUDE_GROUP" 2>/dev/null | cut -d: -f4 | tr ',' '\n' | grep -v '^$'
}

# Get home directory for a user
get_home() {
  getent passwd "$1" 2>/dev/null | cut -d: -f6
}

# Check if user is in exclude list
is_excluded() {
  local user=$1
  local excluded
  for excluded in "${EXCLUDE_USERS[@]}"; do
    [[ $user == "$excluded" ]] && return 0
  done
  return 1
}

# Process a single user
process_user() {
  local user=$1
  local user_home user_rules user_group
  local -i removed=0 kept=0

  user_home=$(get_home "$user")
  [[ -n $user_home ]] || { warn "Cannot find home for ${user@Q}"; return 1; }

  user_rules="$user_home/.claude/rules"
  if [[ ! -d $user_rules ]]; then
    ((VERBOSE)) && info "${user@Q}: no rules directory" || true
    return 0
  fi

  user_group=$(id -gn "$user" 2>/dev/null) || user_group=$(id -g "$user")

  echo "=== Processing ${user@Q} ($user_rules) ==="

  # Create backup directory if needed
  local backup_dir="$user_home/.claude/rules.bak"
  if ((BACKUP && !DRY_RUN)); then
    mkdir -p "$backup_dir"
    chown "$user":"$user_group" "$backup_dir"
  fi

  # Check each file in user rules
  local file filename
  for file in "$user_rules"/*; do
    [[ -f $file ]] || continue
    filename=${file##*/}

    if [[ -f "$ENTERPRISE_RULES/$filename" ]]; then
      # File exists in enterprise - it's a duplicate
      if ((DRY_RUN)); then
        echo "  Would remove: $filename"
      elif ((BACKUP)); then
        mv "$file" "$backup_dir/"
        chown "$user":"$user_group" "$backup_dir/$filename"
        ((VERBOSE)) && echo "  Backed up: $filename" || true
      else
        rm "$file"
        ((VERBOSE)) && echo "  Removed: $filename" || true
      fi
      ((++removed))
    else
      # User-specific file - keep it
      ((VERBOSE)) && echo "  Keeping: $filename (user-specific)" || true
      ((++kept))
    fi
  done

  # Summary for this user
  if ((DRY_RUN)); then
    echo "  Summary: $removed to remove, $kept to keep"
  else
    echo "  Summary: $removed removed, $kept kept"
    if ((BACKUP && removed > 0)); then
      echo "  Backup: $backup_dir"
    fi
  fi

  # Remove empty rules directory
  if ((!DRY_RUN)) && [[ -d $user_rules ]]; then
    local -a remaining=("$user_rules"/*)
    if ((${#remaining[@]} == 0)); then
      rmdir "$user_rules"
      info "Removed empty rules directory"
    fi
  fi

  return 0
}

main() {
  # Parse arguments
  while (($#)); do
    case $1 in
      -h|--help)      show_help; return 0 ;;
      -V|--version)   echo "$SCRIPT_NAME $VERSION"; return 0 ;;
      -n|--dry-run)   DRY_RUN=1 ;;
      -b|--backup)    BACKUP=1 ;;
      -v|--verbose)   VERBOSE=1 ;;
      -x|--exclude)   (($#>1)) || die 22 "Option ${1@Q} requires a username"
                      shift
                      EXCLUDE_USERS+=("$1")
                      ;;
      -*)             die 22 "Unknown option ${1@Q}" ;;
      *)              TARGET_USERS+=("$1") ;;
    esac
    shift
  done

  # Validate
  ((EUID == 0)) || die 1 'This script must be run as root (use sudo)'
  [[ -d $ENTERPRISE_RULES ]] || die 1 "Enterprise rules not found ${ENTERPRISE_RULES@Q}"

  # Get target users
  if ((${#TARGET_USERS[@]} == 0)); then
    mapfile -t TARGET_USERS < <(get_group_members)
  fi

  ((${#TARGET_USERS[@]} > 0)) || die 1 "No users found in group ${CLAUDE_GROUP@Q}"

  # Header
  echo "$SCRIPT_NAME $VERSION"
  ((DRY_RUN)) && echo "[DRY RUN - no changes will be made]" || true
  echo "Enterprise rules: $ENTERPRISE_RULES"
  echo "Target users: ${TARGET_USERS[*]}"
  ((${#EXCLUDE_USERS[@]} > 0)) && echo "Excluded: ${EXCLUDE_USERS[*]}" || true
  echo

  # Process each user
  local user
  local -i processed=0 skipped=0
  for user in "${TARGET_USERS[@]}"; do
    if is_excluded "$user"; then
      ((VERBOSE)) && info "Skipping excluded user ${user@Q}" || true
      ((++skipped))
      continue
    fi

    if process_user "$user"; then
      ((++processed))
    fi
    echo
  done

  # Final summary
  echo "=== Complete ==="
  echo "Processed: $processed users"
  ((skipped > 0)) && echo "Skipped: $skipped users" || true
  ((DRY_RUN)) && echo "Run without --dry-run to apply changes" || true
}

main "$@"
#fin
